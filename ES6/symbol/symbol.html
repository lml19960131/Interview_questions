<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Symbol</title>
</head>
<body>
    <script>
        //ES6:symbol
        let s = Symbol('a');//symbol 不能使用new来定义
        console.log(typeof s);
        console.log(s);

        //symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述
        let s1 = Symbol('foo');
        let s2 = Symbol('bar');
        s1.toString();
        s2.toString();

        //如果Symbol的参数是一个对象就会调用该对象的toString方法。
        const obj = {
            toString() {
                return 'abc';
            }
        };
        const sym =Symbol(obj);
        console.log(sym);
        //没有参数的情况。
        let s3 = Symbol();
        let s4 = Symbol();
        console.log(s3 === s4);
        //有参数的情况
        let s5 = Symbol('lml');
        let s6 = Symbol('lml');
        console.log(s5 === s6);

        //symbol值不能与其他类型的值进行运算，会产生错误
        let sym1 = Symbol('My symbol');
//        console.log('your symbol is' + sym1);
//        console.log('your symbol is ${sym}');


        //作为属性名的symbol
        let mySymbol = Symbol();
        let a = {
            [mySymbol]: 'lml' //作为属性名必须用方括号括起来
        };
        console.log(a[mySymbol]); //lml

        //属性名的遍历：symbol不会出现在for...in、for...of循环中，也不会被object.keys()遍历
        let foo = Symbol('foo');
        let obj2 = {
            [foo] : 'world'
        };
        Object.getOwnPropertySymbols(obj2); //获取symbol属性名需要采用本方法

        //Symbol.for()和Symbol.keyFor()
        //需要重新使用同一个Symbol时，采用Symbol.for方法
        let x = Symbol.for('foo');
        let y = Symbol.for('foo');
        console.log(x === y);


        //内置的symbol：Symbol.hasInstance  Symbol.isConcatSpreadable....
    </script>
</body>
</html>